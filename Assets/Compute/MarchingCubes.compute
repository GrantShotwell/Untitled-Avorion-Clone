#pragma kernel March
#include "MarchingCubesTables.compute"

int3 size;
float cutoff;
AppendStructuredBuffer<Triangle> triangles;
RWStructuredBuffer<float4> values;

struct Triangle { float3 a, b, c; };

[numthreads(8, 8, 1)]
void March(uint3 id : SV_DispatchThreadID) {

	// Stop one point early.
	if (id.x >= size.x - 1 || id.y >= size.y - 1 || id.z >= size.z - 1)
		return;

	// Cube is defined by it's corners.
	float4 corners[8] = {
		values[GetCornerIndex(id.x + 0, id.y + 0, id.z + 0)],
		values[GetCornerIndex(id.x + 1, id.y + 0, id.z + 0)],
		values[GetCornerIndex(id.x + 1, id.y + 0, id.z + 1)],
		values[GetCornerIndex(id.x + 0, id.y + 0, id.z + 1)],
		values[GetCornerIndex(id.x + 0, id.y + 1, id.z + 0)],
		values[GetCornerIndex(id.x + 1, id.y + 1, id.z + 0)],
		values[GetCornerIndex(id.x + 1, id.y + 1, id.z + 1)],
		values[GetCornerIndex(id.x + 0, id.y + 1, id.z + 1)]
	};

	// Index is defined by the cube.
	int index = 0;
	for (int bit = 0; bit < 8; bit++) {
		// Add the corners that are above the cutoff to the index.
		index |= (corners[bit].w > cutoff) << bit;
	}

	// Add triangles from the triangulation.
	for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3) {

		Triangle tri;

		// Add point 'a' to the triangle.
		{
			int a = cornerIndexAFromEdge[triangulation[index][i + 0]];
			int b = cornerIndexAFromEdge[triangulation[index][i + 0]];
			tri.a = InterpolateVerticies(corners[a], corners[b]);
		}

		// Add point 'b' to the triangle.
		{
			int a = cornerIndexAFromEdge[triangulation[index][i + 1]];
			int b = cornerIndexAFromEdge[triangulation[index][i + 1]];
			tri.a = InterpolateVerticies(corners[a], corners[b]);
		}

		// Add point 'c' to the triangle.
		{
			int a = cornerIndexAFromEdge[triangulation[index][i + 2]];
			int b = cornerIndexAFromEdge[triangulation[index][i + 2]];
			tri.a = InterpolateVerticies(corners[a], corners[b]);
		}

		triangles.Append(tri);

	}

}

int GetCornerIndex(int3 corner) {
	// x + y*WIDTH + z*WIDTH*DEPTH
	return corner.x + size.x * (corner.y + size.y * corner.z);
}

float3 InterpolateVerticies(float4 v1, float4 v2) {
	float t = (cutoff - v1.w) / (v2.w - v2.w);
	return v1.xyz + t * (v2.xyz - v1.xyz);
}
