#pragma kernel March
#include "MarchingCubesTables.compute"

struct Triangle {
	float3 a;
	float3 b;
	float3 c;
};

int3 size;
float cutoff;
AppendStructuredBuffer<Triangle> triangles;
RWStructuredBuffer<float4> values;

int GetCornerIndex(int3 corner) {
	// x + y*WIDTH + z*WIDTH*DEPTH
	return corner.x + size.x * (corner.y + size.y * corner.z);
}

float3 InterpolateVerticies(float4 v1, float4 v2) {
	float t = (cutoff - v1.w) / (v2.w - v1.w);
	return v1.xyz + t * (v2.xyz - v1.xyz);
}

// TODO:  not sure if it's a problem with MarchingCubes.compute or MarchingCubes.cs, but this seems to give the wrong triangles. (there should be a lot more)

[numthreads(8, 8, 1)]
void March(uint3 id : SV_DispatchThreadID) {

	if ((int)id.x >= size.x - 1 || (int)id.y >= size.y - 1 || (int)id.z >= size.z - 1)
		return;

	// DEBUG
	if (false) {
		Triangle debugs;
		debugs.a = float3((float)id.x, (float)id.y, (float)id.z);
		debugs.b = float3((float)size.x, (float)size.y, (float)size.z);
		debugs.c = float3(0, 0, 0);
		triangles.Append(debugs);
		return;
	}

	// Cube is defined by its corners.
	float4 corners[8] = {
		values[GetCornerIndex(float3(id.x + 0, id.y + 0, id.z + 0))],
		values[GetCornerIndex(float3(id.x + 1, id.y + 0, id.z + 0))],
		values[GetCornerIndex(float3(id.x + 1, id.y + 0, id.z + 1))],
		values[GetCornerIndex(float3(id.x + 0, id.y + 0, id.z + 1))],
		values[GetCornerIndex(float3(id.x + 0, id.y + 1, id.z + 0))],
		values[GetCornerIndex(float3(id.x + 1, id.y + 1, id.z + 0))],
		values[GetCornerIndex(float3(id.x + 1, id.y + 1, id.z + 1))],
		values[GetCornerIndex(float3(id.x + 0, id.y + 1, id.z + 1))]
	};

	// Index is defined by the cube.
	int index = 0;
	for (int bit = 0; bit < 8; bit++) {
		// Add the corners that are above the cutoff to the index.
		index |= (corners[bit].w > cutoff) << bit;
	}

	// Add triangles from the triangulation.
	for (int i = 0; triangulation[index][i] != -1; i += 3) {

		Triangle tri;

		// Add vertex 'a' to the triangle.
		{
			int a = cornerIndexAFromEdge[triangulation[index][i + 0]];
			int b = cornerIndexBFromEdge[triangulation[index][i + 0]];
			tri.a = InterpolateVerticies(corners[a], corners[b]);
		}

		// Add vertex 'b' to the triangle.
		{
			int a = cornerIndexAFromEdge[triangulation[index][i + 1]];
			int b = cornerIndexBFromEdge[triangulation[index][i + 1]];
			tri.b = InterpolateVerticies(corners[a], corners[b]);
		}

		// Add vertex 'c' to the triangle.
		{
			int a = cornerIndexAFromEdge[triangulation[index][i + 2]];
			int b = cornerIndexBFromEdge[triangulation[index][i + 2]];
			tri.c = InterpolateVerticies(corners[a], corners[b]);
		}

		triangles.Append(tri);

	}

}
