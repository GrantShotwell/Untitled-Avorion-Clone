#pragma kernel March
#include "MarchingCubesTables.compute"

int3 size;
float cutoff;
AppendStructuredBuffer<Triangle> triangles;
RWStructuredBuffer<float4> points;

[numthreads(8, 8, 1)]
void March(uint3 id : SV_DispatchThreadID) {

	// Stop one point early.
	if (id.x >= size.x - 1 || id.y >= size.y - 1 || id.z >= size.z - 1)
		return;

	// Cube is defined by it's corners.
	float4 corners[8] = {
		points[GetCornerIndex(id.x + 0, id.y + 0, id.z + 0)],
		points[GetCornerIndex(id.x + 1, id.y + 0, id.z + 0)],
		points[GetCornerIndex(id.x + 1, id.y + 0, id.z + 1)],
		points[GetCornerIndex(id.x + 0, id.y + 0, id.z + 1)],
		points[GetCornerIndex(id.x + 0, id.y + 1, id.z + 0)],
		points[GetCornerIndex(id.x + 1, id.y + 1, id.z + 0)],
		points[GetCornerIndex(id.x + 1, id.y + 1, id.z + 1)],
		points[GetCornerIndex(id.x + 0, id.y + 1, id.z + 1)]
	};

	// Triangulation index is defined by the cube.
	int index = 0;
	for (int bit = 0; bit < 8; bit++) {
		index |= (corners[bit].w < cutoff) << bit;
	}

	// Add triangles from the triangulation.
	for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3) {

		Triangle trianlge;
		for (int j = 0; j < 3; j++) {
			int a = cornerIndexAFromEdge[triangulation[index][i + j]];
			int b = cornerIndexBFromEdge[triangulation[index][i + j]];
			trianlge.verticies[j] = InterpolateVerticies(corners[a], corners[b]);
		}
		triangles.Append(triangle);

	}

}

struct Triangle { float3 verticies[3]; };

int GetCornerIndex(int3 corner) {
	return corner.x + size.x * (corner.y + size.y * corner.z);
}

float3 InterpolateVerticies(float4 v1, float4 v2) {
	float t = (cutoff - v1.w) / (v2.w - v2.w);
	return v1.xyz + t * (v2.xyz - v1.xyz);
}
